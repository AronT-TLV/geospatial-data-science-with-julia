# Geospatial correlation

```{julia}
#| echo: false
#| output: false
import Pkg
Pkg.activate(".")
using Random
using GeoStats
import CairoMakie as Mke
```

In **Part II** and **Part III** of the book, we learned two important
tools for *efficient* geospatial data science. We learned how **transform
pipelines** can be used to prepare geospatial data for investigation, and
how **geospatial queries** can be used to answer geoscientific questions.
Before we can learn our third tool, we need to review the important concept
of **geospatial correlation**:

::: {.callout-tip}

## Definition

The **geospatial correlation** between two variables $X$ and $Y$ measured at
a distance (or lag) $h$ along any direction is the sample
[Pearson correlation coefficient](https://en.wikipedia.org/wiki/Pearson_correlation_coefficient).
Given $n$ pairs $\{(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)\}$ of
measurements, the coefficient is given by

$$
r_{xy} = \frac{\sum_{i=1}^n (x_i - \bar{x}) (y_i - \bar{y})}{\sqrt{\sum_{i=1}^n (x_i - \bar{x})^2} \sqrt{\sum_{i=1}^n (y_i - \bar{y})^2}}
$$

where $\bar{x}$ and $\bar{y}$ are the mean values.

:::

Let's consider the following synthetic image from the
[GeoStatsImages.jl](https://github.com/JuliaEarth/GeoStatsImages.jl)
module to illustrate the concept for different values of $h$:

```{julia}
using GeoStatsImages

img = geostatsimage("Gaussian30x10")

img |> viewer
```

The `hscatter` plot can be used to visualize the scatter of pairs
$\{(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)\}$ at a given lag $h$.
We can choose a variable $X$ for the horizontal axis, a (possibly different)
variable $Y$ for the vertical axis, and the value of the lag $h$. In
order to reduce the computational costs associated with the plot, we
will sample a subset of measurements from the image:

```{julia}
sample = img |> Sample(1000, replace=false)
```

If we plot the values of the variable `Z` in the horizontal axis and the values
of the same variable measured at lag $h=0$ on the vertical axis, we get points
along the identity line (i.e. no scatter):

```{julia}
hscatter(sample, :Z, :Z, lag=0.0)
```

By increasing the value of the lag, we observe that the correlation is no longer
equal to one, and that the linear fit through the points approaches the horizontal
axis (i.e., zero correlation):

```{julia}
hscatter(sample, :Z, :Z, lag=3.0)
```

```{julia}
hscatter(sample, :Z, :Z, lag=5.0)
```

```{julia}
hscatter(sample, :Z, :Z, lag=10.0)
```

```{julia}
hscatter(sample, :Z, :Z, lag=50.0)
```

The sample Pearson correlation coefficient studied as a function of the lag $h$
is known as the **correlogram function**:

```{julia}
#| echo: false
xs = range(0, stop=10, length=100)
ys = exp.(-xs)
Mke.lines(xs, ys, axis = (xlabel="h", ylabel="cor(h)"), color="black")
```

- The correlogram $cor(h)$ is often a non-increasing function
- It coincides with the usual correlation in data science at $h=0$
- $cor(h) \to 0$ as $h \to \infty$ in most practical cases

The terms **auto-correlogram** ($X = Y$) and **cross-correlogram** ($X \ne Y$) are also
encountered in the literature to differentiate the various geospatial correlations in
the multivariate case. Similarly, the terms **auto-covariance** and **cross-covariance**
are encountered by replacing the correlation by the covariance (non-normalized correlation).

Even though the correlogram function is widely used in other scientific fields, we will review
an alternative statistic of association that is most useful in geospatial data science.

## Variography

::: {.callout-tip}

## Definition

The **variogram function** is a more general alternative to the covariance function that
that does **not** rely on the mean values $\bar{x}$ and $\bar{y}$. It is given by

$$
\gamma_x(h) \approx \frac{1}{2|N(h)|}\sum_{N(h)}(x_i-x_j)^2
$$

where $N(h) = \Big\{(i,j): i\underbrace{\longrightarrow}_{h \text{ units}} j\Big\}$ is the
set of pairs of locations that are $h$ units apart.

In the multivariate case, we can also define the **cross-variogram**:

$$
\gamma_{xy}(h) \approx \frac{1}{2|N(h)|}\sum_{N(h)}(x_i-x_j)(y_i-y_j)
$$

:::

The value $\gamma(h)$ measures the "spread" of the `hscatter` plot. Usually,
at $h=0$ there is no spread, and hence $\gamma(0) = 0$. In most practical
cases $\gamma(h) \to \sigma^2$ as $h \to \infty$ where $\sigma^2$ is the
maximum variance of the process. When this maximum variance exists, we
can write the following relation:

$$
\gamma(h) = \sigma^2 - cov(h) 
$$

```{julia}
#| echo: false
xs = range(0, stop=10, length=100)
ys = 1 .- exp.(-xs)
Mke.lines(xs, ys, axis = (xlabel="h", ylabel="γ(h)"), color="black")
```

Explaining why the variogram is more general than the covariance is out
of scope for this book, but it has to do with the fact that variograms
operate on the "difference process" $(x_i - x_j)$ as opposed to the centered
process $(x_i - \bar{x})$. In particular, it does not require a finite maximum
variance $\sigma^2$.

::: {.callout-note}

The theory of intrinsic random functions of order k (IRF-k) is an advanced concept
from geostatistical theory that explains the generality of the variogram function
[@Chiles2012].

:::

Our goal here is to gain intuition about the variogram function by learning its
four basic elements---**range**, **sill**, **nugget** and **model**---which we
explain below:

```{julia}
#| echo: false
r = 10.0
s = 1.0
n = 0.1
m = GaussianVariogram
g = m(range=r, sill=s, nugget=n)

fig = Mke.Figure()
Mke.Axis(fig[1,1], xlabel="h", ylabel="γ(h)", limits = (nothing, nothing, 0, 1.1))
Mke.plot!(g, maxlag=25, label="model")
Mke.vlines!(r, color="black", linestyle=:dash, label="range")
Mke.hlines!(s, color="teal", linestyle=:dash, label="sill")
Mke.hlines!(n, color="teal", linestyle=:dot, label="nugget")
Mke.axislegend("Elements", position = :rc)
fig
```

### range

The **range** (a.k.a. correlation length) of the variogram controls the average
size of "blobs" in the image. Let's consider two synthetic images with ranges
10 and 30, respectively:

```{julia}
#| echo: false
p = SimulationProblem(CartesianGrid(100, 25), :Z => Float64, 1)

g1 = GaussianVariogram(range=10)
g2 = GaussianVariogram(range=30)
s1 = LUGS(:Z => (; variogram=g1))
s2 = LUGS(:Z => (; variogram=g2))

Random.seed!(2023)
d1 = solve(p, s1)[1]
d2 = solve(p, s2)[1]

fig = Mke.Figure()
viz(fig[1,1], d1.geometry, color = d1.Z, axis = (; title="range: 10"))
viz(fig[2,1], d2.geometry, color = d2.Z, axis = (; title="range: 30"))
fig
```

In the first image, we can clearly visualize the average size of yellow and blue blobs
around 10 pixels (or quadrangles). In the second image, the blobs have an average size
of 30 pixels, which is greater than one of the sides of the grid (100x25 pixels).

### sill

### nugget

### model

## Anisotropy

## Nesting