# Split-apply-combine

In **Part II** of the book, we introduced **transform pipelines** to
process the `values` and the `domain` of geotables using high-level
abstractions that preserve geospatial information. In this chapter, we
start to introduce other tools to **query** geotables after they have been
pre-processed by pipelines.

## Motivation

In geospatial data science, geoscientific questions are often posed in
terms of both the `values` and the `domain` of a geotable. For example:

1. **Where** are the areas with maximum probability of landslide?
2. What is the average rainfall **per watershed** over the last year?
3. How much Lithium will be mined from each **geological unit**?

The word "where" is often present in these questions to indicate that
the answer must be georeferenced. We can effectively answer "where"
questions using the `viewer` and the `Filter` transform from previous
chapters if the variable of interest is already present in the geotable:

```{julia}
#| eval: false
geotable |> Filter(row -> row.probability > 0.9) |> viewer
```

If the variable of interest is not present in the geotable, or if the
"where" word is not present in the original question, then there will
be some reference to "geospatial units" where geostatistics must be
computed. These questions can be answered with a geospatial version of
the **split-apply-combine** strategy [@Wickham2011] from data science.

Our framework provides three macros `@groupby`, `@transform` and `@combine`
to split-apply-combine geotables without losing geospatial information.

## Splitting geotables

## Applying expressions

## Combining geostatistics