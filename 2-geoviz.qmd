# Scientific visualization

```{julia}
#| echo: false
#| output: false
import Pkg
Pkg.activate(".")
```

The visualization ecosystem in Julia is evolving very quickly. Among the various
visualization projects, [Makie.jl](https://github.com/MakieOrg/Makie.jl) by
@Danisch2021 is the most suited for
[scientific visualization](https://en.wikipedia.org/wiki/Scientific_visualization).

Makie.jl is currently organized in backend modules:

- **GLMakie.jl** is the preferred backend for interactive *high-performance* visualization.
- **WGLMakie.jl** is the preferred backend for interactive visualization on the *web browser*.
- **CairoMakie.jl** is the preferred backend for *publication-quality* static visualization.

In this book, we use **CairoMakie.jl**:

```{julia}
import CairoMakie as Mke
```

::: {.callout-note}

We import the backend as `Mke` to avoid polluting the Julia
session with names from the visualization stack.

:::

## viz/viz!

Makie.jl provides a plot recipe system developed after
[Plots.jl](https://github.com/JuliaPlots/Plots.jl) by @Breloff2023,
which enables automatic visualization of custom Julia types.
GeoStats.jl is integrated with this recipe system, and provides
a `viz`/`viz!` function for efficient visualization of geospatial
data.

```{julia}
using GeoStats
```

::: {.callout-note}

Julia will trigger the compilation of `viz`/`viz!` in GeoStats.jl
whenever a Makie.jl backend is loaded in the same session.

:::

For illustration purposes, let's load "raster data" from disk using
the GeoIO.jl module:

```{julia}
#using GeoIO

#img = GeoIO.load("data/image.jpg")
```

Since the `.jpg` file format doesn't contain a coordinate reference
system, the framework will assume that the `CartesianGrid` starts at
the origin:

```{julia}
#img.geometry
```

The `viz` function can be used to visualize geometries within a domain
using colors taken from any vector of [Colors.jl](https://github.com/JuliaGraphics/Colors.jl):

```{julia}
#viz(img.geometry, color = img.color)
```

Since it is common to use another column of the `GeoTable` as
the vector of colors, the framework will automatically convert
raw vectors of (continuous and categorical) values into color
objects:

```{julia}
#viz(img.geometry, color = 1:length(img.color))
```

We could also pass a single color for all geometries:

```{julia}
#viz(img.geometry, color = "teal")
```

Or pass a random vector of transparencies:

```{julia}
#viz(img.geometry, color = img.color, alpha = rand(length(img.color)))
```

To really see the benefits of the framework, let's load "vector data"
from disk and visualize it:

```{julia}
#gis = GeoIO.load("data/geotable.geojson")

#viz(gis.geometry, color = 1:4)
```

The `viz!` function can be used to visualize two or more objects in the scene:

```{julia}
#viz(img.geometry, color = img.color)
#viz!(gis.geometry, color = 1:4)

# display current figure
#Mke.current_figure()
```

Let's add an additional set of points:

```{julia}
#pts = [Point(-20, -10), Point(-20, 0), Point(-40, 10)]

#viz!(pts, color = 1:3)

#Mke.current_figure()
```

And a set of line segments to conclude the example:

```{julia}
#seg = [Segment((-40, -10), (0, 0)), Segment((-40, 0), (-20, 10))]

#viz!(seg, color = 1:2)

#Mke.current_figure()
```

::: {.callout-note}

## Tip for all users

Makie.jl can set the aspect ratio of the axis after the visualization is created.
The following code can be used to adjust the aspect ratio for the data in the scene:

```{julia}
#ax = Mke.current_axis()
#ax.aspect = Mke.DataAspect()
#Mke.current_figure()
```

:::

::: {.callout-note}

## Tip for advanced users

Makie.jl dispatches the `viz` and `viz!` functions whenever it encounters
a geospatial domain, a vector of geometries or a single geometry from Meshes.jl.
This means that you can replace `viz` with `Mke.plot` and `viz!` with `Mke.plot!`
in scripts and the result will be the same.

:::

## viewer

As geospatial data scientists we are often interested in quick inspection
of intermediate results from multivariate statistical analysis. Visualizing
all the variables manually with `viz`/`viz!` can be very time consuming.
To address this issue, the framework provides a basic `viewer` that displays
all variables stored in a `GeoTable`:

```{julia}
geotable = georef((A=rand(1000), B=rand(1000)), rand(3, 1000))

viewer(geotable)
```

It adds interactive elements to the scene, including a menu to select the
variable used as color, and a color bar that automatically updates upon
selection of new variables on the menu. The `viewer` will be particularly
useful when we start to work with geospatial transforms in [Part II](4-feattrans.qmd)
of the book. The pipe operator (`|>`) in Julia will be preferred for reasons
that will become clearer later:

```{julia}
img = georef((A=rand(1000), B=rand(1000)), CartesianGrid(10, 10, 10))

img |> viewer
```

We are now equiped with a set of visualization functions that can
really improve the speed at which we explore and analyze geospatial data.
These functions provide a consistent set of aesthetic options that we
will cover in more detail with future examples.

Before we start learning the advanced features of the framework, we would
like to say a few words about integration with existing GIS technology.