# What are transforms?

```{julia}
#| echo: false
#| output: false
import Pkg
Pkg.activate(".")
using GeoStats
import CairoMakie as Mke
```

## Motivation

In **Part I** of the book, we learned that our `GeoTable` representation
of geospatial data provides the data access pattern of the `DataFrame`,
a feature that is very convenient for data science. To recap, let's
consider the following geotable with four random variables:

```{julia}
N = 10000
a = [2randn(N÷2) .+ 6; randn(N÷2)]
b = [3randn(N÷2); 2randn(N÷2)]
c = randn(N)
d = c .+ 0.6randn(N)

table = (; a, b, c, d)

gt = georef(table, CartesianGrid(100, 100))
```

We can easily retrieve the "a" column of the geotable as a vector,
and plot its histogram:

```{julia}
Mke.hist(gt.a, color = "gray80")
```

We can compute the cross-correlation between columns "a" and "b":

```{julia}
cor(gt.a, gt.b)
```

And even inspect bivariate distributions of the `values` of the geotable
with [PairPlots.jl](https://github.com/sefffal/PairPlots.jl):

```{julia}
using PairPlots

pairplot(values(gt))
```

The pattern is certainly useful to answer geoscientific questions that can
be answered on the basis of marginal analysis (i.e. entire columns treated
as measurements of a single random variable). However, the answers to many
questions in geosciences depend on **where** the measurements were made.

Attempting to answer geoscientific questions with basic access to rows and
columns can be very frustrating. In particular, this approach is prone to
unintentional removal of geospatial information:

```{julia}
gt.a
```

::: {.callout-note}

Any script that is written in terms of direct column access has the potential
to discard the special `geometry` column, and become unreadable very quickly
with the use of auxiliary indices for rows.

:::

We propose a new approach to **geospatial** data science with the concept of
**geospatial transforms**, which we introduce in three steps with practical
examples:

1. Feature transforms
2. Geometric transforms
3. Geospatial transforms

## Feature transforms

A feature transform is a function that takes the `values` of the geotable
and produces a new set of values over the same geospatial `domain`. The
framework provides over 30 such transforms, ranging from basic selection of
columns, to data cleaning, to advanced multivariate statistical transforms.

### Basic

Let's start with two basic and important transforms, `Select` and `Reject`.
The `Select` transform can be used to select columns of interest from a
geotable:

```{julia}
gt |> Select("a", "b") # select columns "a" and "b"
```

In the example above, we selected the columns "a" and "b" explicitly, but 
`Select` has various methods for more flexible column selection:

```{julia}
gt |> Select(1:3) # select columns 1 to 3
```

```{julia}
gt |> Select(r"[bcd]") # columns matching regular expression
```

A convenient method is also provided to select and rename columns:

```{julia}
gt |> Select("a" => "A", "b" => "B")
```

The `Reject` transform can be used to reject columns from a geotable
that are not relevant for a given analysis. It supports the same column
specification of `Select`:

```{julia}
gt |> Reject("b") # reject column "b"
```

::: {.callout-note}

Unlike direct column access, the `Select` and `Reject` transforms
preserve geospatial information.

:::

::: {.callout-note}

## Tip for all users

The `Select` transform can be used in conjuntion with the `viewer`
to quickly visualize a specific variable:

```{julia}
gt |> Select("a") |> viewer
```

:::

The `Rename` transform can be used to rename specific columns of a geotable.
It preserves all other columns that are not part of the column specification:

```{julia}
gt |> Rename("a" => "A", "b" => "B")
```

The `Identity` transform can be used as a placeholder to forward the geotable
without modifications to the next transform:

```{julia}
gt |> Identity()
```

The `RowTable` and `ColTable` transforms change the underlying table representation
of the `values` of the geotable as discussed in the first chapter of the book:

```{julia}
rt = gt |> RowTable()
```

```{julia}
using Tables

Tables.isrowtable(values(rt))
```

The `Functional` transform can be used to apply a function to columns of a geotable in place:

```{julia}
gt |> Functional(cos) |> values |> pairplot
```

```{julia}
gt |> Functional("a" => cos, "b" => sin) |> values |> pairplot
```

The `Map` transform can be used to create new columns from existing columns in the geotable.
It takes a column specification, calls a function on the selected columns row-by-row, and returns
the result as a new column:

```{julia}
gt |> Map("a" => sin, "b" => cos => "cos(b)")
```

```{julia}
gt |> Map([2, 3] => ((b, c) -> 2b + c) => "f(b, c)")
```

The name of the resulting column can be provided or omitted. If the name is omitted like in the
example above with the column "a", it is created by concatenation of column and function names.

::: {.callout-note}

The `Map` transform mimicks the behavior of the `transform` function in DataFrames.jl, except
that it always broadcasts the functions to the rows of the selected columns and always produces
a single column for each function.

::: 

To filter rows in the geotable based on a given predicate (i.e., a function that returns
`true` or `false`), we can use the `Filter` transform:

```{julia}
gt |> Filter(row -> row.a < 0 && row.b > 0)
```

To sort rows based on specific columns we can use the `Sort` transform:

```{julia}
gt |> Sort("a", "b")
```

This transform accepts all options of the `sortperm` function in Julia, including the
option to sort in reverse order:

```{julia}
gt |> Sort("a", "b", rev=true)
```

### Cleaning

Some feature transforms are used to clean the data before geostatistical analysis. 
For example, the `StdNames` transform can be used to standardize variable names
that are not very readable due to file format limitations. To illustrate this
transform, let's create a geotable with unreadable variable names:

```{julia}
ut = gt |> Select("a" => "aBc De-F", "b" => "b_2 (1)")
```

We can standardize the names with:

```{julia}
ut |> StdNames()
```

By default the transform, uses the `:uppersnake` naming convention. Other conventions
can be specified depending on personal preference:

```{julia}
ut |> StdNames(:uppercamel)
```

```{julia}
ut |> StdNames(:upperflat)
```

The `Replace` transform can be used to replace specific values in the geotable by new
values that are meaningful to the analysis:

```{julia}
gt |> Replace(-999 => missing, NaN => missing)
```

Although it could be used to replace `missing` values by new values, there is a specific
transform for this purpose named `Coalesce`:

```{julia}
ct = georef((a=[1,missing,3], b=[4,5,6])) |> Coalesce(value=2)
```

::: {.callout-note}

Unlike `Replace`, the `Coalesce` transform also changes the column type to make sure that
no `missing` values can be stored in the future:

```{julia}
typeof(ct.a)
```

:::

In many applications, it is enough to simply drop all rows for which the selected column
values are `missing`. This is the purpose of the `DropMissing` transform:

```{julia}
georef((a=[1,missing,3], b=[4,5,6])) |> DropMissing()
```

### Statistical

Sample
Coerce
Levels
Indicator
OneHot
Center
Scale
MinMax
Interquartile
ZScore
Quantile
EigenAnalysis, PCA, DRS, SDS
ProjectionPursuit
Remainder
Closure
LogRatio, ALR, CLR, ILR

## Geometric transforms

### Basic

Translate
Rotate
Stretch
StdCoords
UniqueCoords

### Advanced

Repair
Bridge
LambdaMuSmoothing, LapaceSmoothing, TaubinSmoothing

## Geospatial transforms

Detrend
Potrace