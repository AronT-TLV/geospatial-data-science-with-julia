# Basic interpolation

```{julia}
#| echo: false
#| output: false
import Pkg
Pkg.activate(".")
using GeoStats
import CairoMakie as Mke
```

A very common task in geospatial data science is **geospatial interpolation**,
i.e., predicting variables on geometries that lie between two or more geometries that
have measurements. In this chapter, we will exploit **geospatial correlation**
to make good predictions of continuous variables over an entire domain based on
sparse measurements, which are usually stored on a `GeometrySet`.

The basic idea behind most geostatistical interpolation methods is weighted
combination of values from neighboring geometries. Given a geometry $u$, we want
to estimate the value of the variable at this geometry $z(u)$ using weighted
combinations of measurements from neighboring geometries $u_i,\ i=1,2,\ldots,n$:

$$
z(u) = \lambda_1 z(u_1) + \lambda_2 z(u_2) + \cdots + \lambda_n z(u_n)
$$

The methods differ in the way they compute the weights $\lambda_i,\ i=1,2,\ldots,n$,
and we will cover two basic methods from classical literature: IDW and Kriging.

## IDW

In Inverse Distance Weighting (IDW), the weights are computed in terms of
distances $d(u, u_i)$ to the neighboring geometries:

$$
\lambda_i = \frac{1}{\sum_{i=1}^n {d(u, u_i)}^\beta}
$$

This basic idea was proposed by @Shepard1968, who also studied the effect of the
exponent $\beta$ in the interpolation results. Here, we will visualize the results
using synthetic data:

```{julia}
data = georef((z=[1, 0, 1],), [(25, 25), (50, 75), (75, 50)])
```

```{julia}
data |> viewer
```

First, we need to the define the domain of interpolation, i.e., the geometries
where we want to estimate the variable $z$. In this case, we will perform
interpolation on a 2D `CartesianGrid`:

```{julia}
grid = CartesianGrid(100, 100)
```

With the measurements of the variable $z$ in the geotable, and the domain of
interpolation, we can define the `EstimationProblem` for the variable:

```{julia}
prob = EstimationProblem(data, grid, :z)
```

The `IDW` solver provides options for the number of neighboring geometries and
for the exponent:

```{julia}
idw = IDW(:z => (; exponent=1))
```

We can solve the problem and visualize the result:

```{julia}
sol = solve(prob, idw)
```

```{julia}
sol |> viewer
```

To visualize the effect of the exponent, let's extract the solution along the
line segment between two of the measurements, and visualize it:

```{julia}
seg = Segment((25, 25), (50, 75))
```

```{julia}
z = sol[seg, :z]
```

```{julia}
Mke.lines(z, label = "β=1")
```

We observe that the exponent $\beta=1$ leads to a gradual transition
from the value $1$ at location $(25, 25)$ to the value $0$ at location
$(50, 75)$.

Let's repeat the process with increasing values of the exponent:

```{julia}
fig = Mke.Figure()
Mke.Axis(fig[1,1])
for β in [1,2,3,4,5]
  idw = IDW(:z => (; exponent=β))
  sol = solve(prob, idw)
  Mke.lines!(sol[seg, :z], label = "β=$β")
end
Mke.axislegend(position = :lb)
Mke.current_figure()
```

The larger is the exponent, the more abrupt is the transition of values
between the two locations. In addition, the IDW solution will converge
to the nearest neighbor solution as $\beta \to \infty$:

```{julia}
idw = IDW(:z => (; exponent=100))

solve(prob, idw) |> viewer
```

Custom distances from [Distances.jl](https://github.com/JuliaStats/Distances.jl)
may be used in place of the `Euclidean` distance to meet specific application
requirements (e.g. `Haversine` distance on the sphere):

```{julia}
idw = IDW(:z => (; distance=Chebyshev()))

solve(prob, idw) |> viewer
```

## Kriging

In Kriging [@Matheron1971], the weights are computed using **geospatial correlation**.
More specifically, they are the solution to a linear system of equations produced
with a theoretical variogram model $\gamma$:

$$
\begin{bmatrix}
\mathbf{G} & \mathbf{1} \\
\mathbf{1}^\top & 0
\end{bmatrix}
\begin{bmatrix}
\mathbf{\lambda} \\
\nu
\end{bmatrix} =
\begin{bmatrix}
\mathbf{g} \\
1
\end{bmatrix}
$$

where $\mathbf{G}_{ij} = \gamma(u_i, u_j)$ and $\mathbf{g}_i = \gamma(u, u_i)$ and
$\nu$ is the [Lagrange multiplier](https://en.wikipedia.org/wiki/Lagrange_multiplier)
associated with the constraint $\mathbf{1}^\top \mathbf{\lambda} = 1$. The system
of equations above is known as *Ordinary Kriging*, but many other variants are
supported by the framework.

::: {.callout-note}

The book by @Olea1999 is a good resource to learn the different systems of
of equations associated with Kriging interpolation. Names such as *Simple Kriging*
*Ordinary Kriging*, *Universal Kriging* are quite popular.

:::

Unlike `IDW`, the `Kriging` solution is a function of pairwise evaluations of distances
between geometries with measurements, represented in the matrix $\mathbf{G}$. The
pairwise evaluations account for possible redundancy in the measurements, which leads
to improvements in the estimates:

```{julia}
krig = Kriging(:z => (; variogram=GaussianVariogram(range=30.0)))

solve(prob, krig) |> viewer
```

::: {.callout-note}

## Tip for all users

In this example, the variogram matrix $\mathbf{G}$ is built with pairwise evaluations
between `Quadrangle` geometries:

```{julia}
γ = GaussianVariogram()

γ(grid[1], grid[2])
```

This automatic **change of support** from `Point` to `Quadrangle` geometries is possible
with numerical integration, but can be computionally intensive for some applications with
large domains.

If computational performance is more important than accuracy, then a `GeometrySet` of
centroid `Point`s can be used as the domain of interpolation:

```{julia}
pset = GeometrySet(centroid.(grid))
```

:::

In the previous chapter, we learned how the **range** of the variogram determines
the average size of the "blobs" in the image. Let's illustrate this concept again
for increasing values of this parameter:

```{julia}
fig = Mke.Figure()
Mke.Axis(fig[1,1])
for r in [10,20,30,40,50]
  γ = GaussianVariogram(range=r)
  krig = Kriging(:z => (; variogram=γ))
  sol = solve(prob, krig)
  Mke.lines!(sol[seg, :z], label = "range=$r")
end
Mke.axislegend(position = :lb)
Mke.current_figure()
```

The larger is the range, the less abrupt is the transition of values between the
two locations. Similar visualizations can be produced by varying the **sill**, the
**nugget** and the **model** of the variogram.

## 3D example

Coming soon...

## Congratulations!